import BreadcrumbThree from "@/components/common/breadcrumb/BreadcrumbThree";
import FooterFour from "@/layouts/footers/FooterFour";
import HeaderOne from "@/layouts/headers/HeaderOne";
import FancyBanner from "@/components/common/FancyBanner";
import useTranslation from "next-translate/useTranslation";
import BlogMainSection from "@/components/blogs/common-blog/BlogMainSection";
import { GetServerSideProps } from "next";
import { fetchBlogPosts } from "@/services/api";
import { useStore } from "@/stores/storeContext";
import { useEffect } from "react";

interface BlogProps {
  serverBlogPosts: any[];
}

const Blog = ({ serverBlogPosts }: BlogProps) => {
  const { t } = useTranslation("translations");
  const { blogStore } = useStore();

  // Initialize store with server-side data immediately, without loading state
  useEffect(() => {
    // When the blog page mounts, ensure we're using SSR data and not loading
    if (serverBlogPosts && serverBlogPosts.length > 0) {
      // Set loading to false and update posts in a single operation
      blogStore.setSSRBlogPosts(serverBlogPosts as []);
    } else {
      // If no server posts, ensure loading is false to prevent redirect loops
      blogStore.loading = false;
    }

    // Cleanup function to prevent state conflicts when navigating away
    return () => {
      // Reset the loading state when component unmounts to prevent conflicts
      blogStore.loading = false;
    };
  }, [serverBlogPosts]);

  return (
    <>
      <HeaderOne />
      <BreadcrumbThree
        title={t("blog.title")}
        link_title={t("blog.title")}
        background={8}
        style={false}
      />
      <BlogMainSection />
      <FancyBanner />
      <FooterFour />
    </>
  );
};

export const getServerSideProps: GetServerSideProps = async (context) => {
  try {
    const lang = context.locale || "en";
    console.log(`[Blog Index] Fetching blog posts with language: ${lang}`);
    console.log(`[Blog Index] API Endpoint: ${process.env.NEXT_PUBLIC_SERVER_URL}/api/blog/posts`);
    
    // Add timeout to prevent hanging requests
    const blogPostsPromise = fetchBlogPosts(lang);
    const timeoutPromise = new Promise((_, reject) => 
      setTimeout(() => reject(new Error('Blog fetch timed out')), 10000)
    );
    
    // Race between the actual fetch and the timeout
    const blogPosts = await Promise.race([blogPostsPromise, timeoutPromise]);
    
    console.log(`[Blog Index] Fetch complete. Found ${blogPosts?.length || 0} posts.`);
    if (blogPosts && blogPosts.length > 0) {
      console.log(`[Blog Index] First post title: ${blogPosts[0].title || 'No title'}`);
    } else {
      console.log('[Blog Index] No posts found or empty response');
    }
    
    // Add a hard-coded test post for debugging
    const testPost = {
      id: "test-1",
      title: "Test Post (Server-Generated)",
      content: "<p>This is a test post generated by the server to verify rendering.</p>",
      image: "/assets/img/blog/default-thumbnail.jpg",
      created_at: new Date().toISOString(),
      author: "System"
    };
    
    const allPosts = Array.isArray(blogPosts) ? [...blogPosts, testPost] : [testPost];
    
    return {
      props: {
        serverBlogPosts: allPosts,
      },
    };
  } catch (error) {
    console.error('[Blog Index] Error fetching blog posts:', error);
    
    // Return a test post so the UI can render something
    const testPost = {
      id: "test-error",
      title: "Test Post (Error Fallback)",
      content: "<p>This is a fallback post generated when an error occurred fetching the real posts.</p>",
      image: "/assets/img/blog/default-thumbnail.jpg",
      created_at: new Date().toISOString(),
      author: "System"
    };
    
    return {
      props: {
        serverBlogPosts: [testPost],
      },
    };
  }
};

export default Blog;
